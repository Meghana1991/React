1)Babel is preprocessor used to detect the html code in the javascript file and parse it.
2)React can render the components or HTML tags using the
  ReactDOM.render(<Component>,where?)
  ReactDOM.render(<App />,document.getElementById("root"))

3)A Component which owns the state should be the one modifying it.

33)DOM RENDERING -

- React's render() DOESNOT render the HTML/JSX to the real DOM instead it updates in the virtual dom.The render() function's code doesnot hit the real dom directly. Again on top of it we can stil handle the changes of the render()'s virtual dom's updation or not using shouldComponentUpdate

-render() when called compares previous or old virtual dom with the new virtual dom which is just formed by render function. It compares and checks if anything is changed in virtual doms, if yes then only it modifies the real dom

-The virtual dom is just dom representation in the javascript.It keeps both the virtual doms in the javascript only.The elements are all represented in the pure javascript. These virtual doms are compared and if the difference exists then the real dom is updated

-The rerendering after javascript virtual doms comparison again rerender COMPLETE real dom BUT does only those which are changed based on the difference example if button text changes then it updates only button text instead of rerendering the button

3)The component App should return some html code always. Any component is expected to do this.
4)Whatevr HTML code writen inside the render() will be internally converted to React.createElement. Check files for example
5)The JSX expects the element to have className instead class. The reason being that the JSX converts the HTML to react element internally in the javascript and the keyword class is reserved word in javascript so we need to use className
6)The JSX expects the element we are defining to be under root tag and not like siblings

34)JSX is javascript so inorder to have multiple adjacent tags WITHOUT HAVING to be under same div, can be handled like [el1,el2]

35)ANother way of doing it is by using a wrapper component which just wraps and does nothing

36)Another way from React 16 Onwards is by using REACT.fragment. Wrapping the elements in the React.fragment or just fragment tag. Imagine there is a scenario where i need to return columns of table. So in such cases I cant use div to wrap elements.

37)If you want to have the element with the style or className then use a wrapper like Auxillary component that picks up the props as the classname of actual component and assigns to children returned

7)By using ES6 we can get access to this keyword
8)React considers div as HTML whereas Div as custom component. Hence we need to give custom component with Caps at first letter
9)When creating components, you have the choice between two different ways:

Functional components (also referred to as "presentational", "dumb" or "stateless" components - more about this later in the course) => const cmp = () => { return <div>some JSX</div> } (using ES6 arrow functions as shown here is recommended but optional)

class-based components (also referred to as "containers", "smart" or "stateful" components) => class Cmp extends Component { render () { return <div>some JSX</div> } } 

13)props
The props are basically the object form of custom tag which is in HTML. Here we get all the attributes given to the tag along with the children elements

11)In regular javascrpt the variables are present in the class with var or let form. In this class which extends from component will have the variables in the form of state which is reserved keyword

12)Beauty of the state is that the react will re render the dom on change of state. Anything you change in state, the dom render happens by react trigger

props  and state  are CORE concepts of React. Actually, only changes in props  and/ or state  trigger React to re-render your components and potentially update the DOM in the browser (a detailed look at how React checks whether to really touch the real DOM is provided in section 6).

props  allow you to pass data from a parent (wrapping) component to a child (embedded) component.

14)We should not change the state directly by accessing it instead react provides us setState methos to modify state or props

14.5)Javascript inside the JSX is written inside {} always whether it is condition or is a variable binding or a state anything

15)React always watches for state or props and compares the old to new value and changes in the DOM
16) The state and setState comes along with Component extends which works only for class based
17)One can pas methods and vars to the custom tag / component
18)One cannot access state inside the function code
19)https://stackoverflow.com/questions/34361379/are-arrow-functions-and-functions-equivalent-exchangeable
20)render() gets called everytime the dom is rendered.
21)writing the if cond inside the JSX is not allowed as it accepts only simple statements
22)Map transforms a particular array into something else
23)React generally re renders everything in the DOM, its good to mention a KEY property which tells React to keep track and CHANGE only when CHANGE is seen and not re render always to dom
24)Keys help React identify which items have changed, are added, or are removed. Keys should be given to the elements inside the array to give the elements a stable identity
25)React Developer Tools is the extension used for debugging
26)ErrorBoundries for error or exception handling like api call failures etc
27)The literal difference before React 16 is that one has state, and the other doesn't. That means the stateful components are keeping track of changing data, while stateless components print out what is given to them via props, or they always render the same thing. Notice the stateless component is written as a function.
28)Now the stataful components are not just class but can be anything that manages state and stateless are not always functional component in React 16+. Even functional component can manage state in React 16+. But functional component are usually presentational which doesnot manage state and are for showing in ui for fancy
29)state and props both can be used in the class component.
30)Component Lifecycle as name suggests comes only in the Class based. In functional however you should be using react hooks there
https://www.udemy.com/react-the-complete-guide-incl-redux/learn/lecture/13585862#overview
31)LifeCycle Create
  constructor
    > getDerivedStateFromProps
      > render
        > child components
          > componentDidMount
32)getDerivedStateFromProps is invoked right before calling the render method, both on the initial mount and on subsequent updates. It should return an object to update the state, or null to update nothing.Very rarely used
33)componentDidMount() is invoked immediately after a component is mounted (inserted into the tree). Initialization that requires DOM nodes should go here. If you need to load data from a remote endpoint, this is a good place to instantiate the network request.

This method is a good place to set up any subscriptions. If you do that, don’t forget to unsubscribe in componentWillUnmount().

You may call setState() immediately in componentDidMount(). It will trigger an extra rendering, but it will happen before the browser updates the screen. This guarantees that even though the render() will be called twice in this case, the user won’t see the intermediate state. Use this pattern with caution because it often causes performance issues. In most cases, you should be able to assign the initial state in the constructor() instead. It can, however, be necessary for cases like modals and tooltips when you need to measure a DOM node before rendering something that depends on its size or position.

This form of setState() is also asynchronous, and multiple calls during the same cycle may be batched together. For example, if you attempt to increment an item quantity more than once in the same cycle, that will result in the equivalent of:

Object.assign(
  previousState,
  {quantity: state.quantity + 1},
  {quantity: state.quantity + 1},
  ...
)

34)shouldComponentUpdate - it allows to stop the updating process on change of props or state
This method only exists as a performance optimization. Do not rely on it to “prevent” a rendering, as this can lead to bugs. Use shouldComponentUpdate() to let React know if a component’s output is not affected by the current change in state or props. The default behavior is to re-render on every state change, and in the vast majority of cases you should rely on the default behavior.
35)React hooks are a new way (still being developed) to access the core features of react such as state without having to use classes, in your example if you want to increment a counter directly in the handler function without specifying it directly in the onClick prop, you could do something like:
...
const [count, setCounter] = useState(0);
const [moreStuff, setMoreStuff] = useState(...);
...
const setCount = () => {
    setCounter(count + 1);
    setMoreStuff(...);
    ...
};
and onClick:

<button onClick={setCount}>
    Click me
</button>

React.memo is a higher order component. It’s similar to React.PureComponent but for function components instead of classes.

If your function component renders the same result given the same props, you can wrap it in a call to React.memo for a performance boost in some cases by memoizing the result. This means that React will skip rendering the component, and reuse the last rendered result.

function MyComponent(props) {
  /* render using props */
}
function areEqual(prevProps, nextProps) {
  /*
  return true if passing nextProps to render would return
  the same result as passing prevProps to render,
  otherwise return false
  */
}
export default React.memo(MyComponent, areEqual);

36)useEffect - is a react hook which combines componentDidMount and ComponentDidUpdate
Here it gets called on every render. Whenever the virtual DOM changes, the render gets called. Here you can call BE calls.
27)Differences between componentDidMount and ComponentDidUpdate
componentDidMount()

componentDidMount() is invoked immediately after a component is mounted. Initialization that requires DOM nodes should go here. If you need to load data from a remote endpoint, this is a good place to instantiate the network request. Setting state in this method will trigger a re-rendering.

componentDidUpdate()

componentDidUpdate() is invoked immediately after updating occurs. This method is not called for the initial render.

the DOM is available and - componentDidMount
properties got changed - componentDidUpdate

If you’re familiar with React class lifecycle methods, you can think of useEffect Hook as componentDidMount, componentDidUpdate, and componentWillUnmount combined.
28)useEffect = componentDidMount + componentDidUpdate
First time - componentDidMount
Any change - componentDidUpdate

I want to useEffect only on certain property change 
28)componentWillUnmount is used whenever you want to do some action right before the component is removed.
usually clean up work will be done in this cycle. As mentioned above we can use useEffect for the same reason with function. Check example

29)Whenever the portion of DOM changes like may be some content change, then the entire render() gets called which is needless and to avoid it we have shouldComponentUpdate and used mainly for class comps

30)Another way to do it is by using react.memo() for functional components

31)shouldComponentUpdate can be used when a certain property in the props of certain component check is present. If the entire props should be checked then use PureComponent which checks the complete props check instead of single property in prop.

shouldComponentUpdate(nextProps) {
  if (this.props.message === nextProps.message) {
    return false
  }
}

32)Assume that there is a prop like prop.persons. 
if(nextProps.persons !== prop.persons)
Means that the props.person is a pointer in memory location as it is a variable.If anything changes in the mem loc then the trigger happens

38)DOM manipulation like may be focus input element or modify the text of label element or doing anything in the element html level is by using the refs

39)When we pass props to the components where we might chain it like passing to component C from A via B where B would not be using the props.

40)So to overcome the above problem we will use the context. It is like a you can pass the context variable across multiple components (like angular services)

41)Running npm run eject copies all the configuration files and the transitive dependencies (Webpack, Babel, ESLint, etc) right into your project so you have full control over them.

42)Components are the ones which are presentational purpose only whereas the containers are the ones which are meant for stateful components. Both cases irrespective of the class or hooks

43)Layout folder is a presentational purpose hence place it in the Components

44)Axios is a lightweight HTTP client based similar to a Fetch API. Axios is promise-based async/await library for the readable asynchronous code. We can easily integrate with React.js, and it is effortless to use in any frontend framework.

45)React doesnot have any router included inside. We need to install separate package not inside box.
npm install react-router-dom

46)BrowserRouter will enable the routing so we need to wrap the base component with it in App.js

47)The same route can be having multiple data. Like the / can be rendering multiple Components
Also the data for route / matches all the routes. Hence we need to make it exact which means only for /. Like pathMatch = full in angular

48)The router can still work with the <a href> but the problem comes as it will reload the page.
To avoid the default behavior the <a href> to be replaced with <Link> which accepts 'to' which can be either a string or a object

49)Whenever the route occurs the component which is loaded will have some information like the path and other params which will be present in props

50)In case of angular, the routeParams subscriptions can be got only if the route has occured in routeconfig. In react the props will have those information in props if it is routed from <Route> almost same like angular. In case you have component which renders another component where still you would like to have the route information, then we need to use simple props to pass it to the child component in the props. Another approach would be withRouter which is a hoc

51)Absolute Path - will always attach the route we have given to the Domain like 
example.com/my-route
If my current path is example.com/detail/new-post and when i use absolute path it will add to example.com/new-post omitting the detail.

52)The route to="/:id" means anything after the / will be falling in this route. Assume that there is to="/some-post" which will also come under this. Temporary solution is to place the to="/some-post" first and then the "/:id" as the parsing happens from top to bottom

54)The /:id and /something will always load its contents. Both would be loaded when url hits. To overcome this we need to use Switch will tells React router to always consider the each route as unique and consider the first occurance always. Here the order matters a lot.

55)We can navigate to a particular route using <Link to> or by programmatic way.

56)Nested Routes are usually like child routes in angular.But here we define it inside the place where it is supposed to render

57)There are multiple ways to redirect
             * 1) Use the below method where Redirect tag is used
             * 2) Use this.props.history.push method
Redirect replaces the page, when user clicks browser back, it doesnot take u to back page
The history push will just push the page to the stack which will go to back page 
ANother way of making the history push work like redirect is by using history replaced

58)Lazy Loading means loading the components only when the route is hit and to avoid loading of complete application load.

59)Lazy loading can be implemented in React 16 by dynamically importing the module in the file.

60)Whenever the request goes to server, the server should give back index html always because there are scenarios where /posts would obviously not be known to server and it will result in the 404 error. Server should return index if the route is not found as it is a SPA so

61)If the application is hosted in the example.com, then good. If example.com/my-app then we should tell the react from where the application should begin. We need to define this in the router in BrowserRouter basename="/my-app"

62)Check for routing module for routing example

63)Redux is used for state management or store management of data. In redux we store data in centralised format. We can achieve it in simple javascript by global variables but the problem is the react doesnot detect all javascript related changes

64)Store is a gaint javascript object which stores the entire application state.

65) From the component we will request for store change, so we will dispatch an action. The reducer present in the store will check for the action and then modify the store as per the request. In all the areas where the store value is used would change, hence we need to subscribe and listen it

66)To use react-redux, install it and use Provider tag to enclose app component.

67)Each component would have connect() which will have params like which part slice of state to modify and which actions are going to be displayed by component

68)connect accepts multiple args where the first stands for the piece of state to be listened to and next will be the fn to dispatch

69)in Reducer, we are using arr.concat instead of arr.push because push manipulates the original array where as the concat creates a new array with copy of the contents

70)When application gets bigger, we need to have multiple reducers. In that case we would be combining them all using combineReducers from redux

71)Steps to use redux
  - Install redux and react-redux
  
72)Middleware is to provides a third-party extension point between dispatching an action, and the moment it reaches the reducer

73)Middleware will get the input (which might be action) and works on it and then returns the action. It is like interceptor.
The reducer function has to run synchronously

74)There is no way u can call api in the reducer generally but if you use action creators u can create async calls

75)Middleware are used to do some action during the dispatch and action.One needs to import applyMiddleware inorder to achieve Middleware.

76)The reducers are synchronous and all lines execute in synchronous way in Middleware.Inorder to make reducer work asynchronous way or make the reducer make API call, we need to install thunk.

77)The below code in HTML will be as
<h1>Shopping List for {props.name}</h1>
  <ul>
    <li>Instagram</li>
    <li>WhatsApp</li>
    <li>Oculus</li>
  </ul>

React.createElement("h1",null, "Shopping List", props.name),React.createElement("ul",null,React.createElement("li",null,"Instagram"),React.createElement("li",null,"WhatsApp"),React.createElement("li",null,"Oculus")));

78)Virtual DOM is something which is created by react which is lightweight representation of the real DOM. React DOM is used to render the HTML code or the custom component code in to the real dom

79)Extends vs Implement. Implement is used for interface where one has to follow strict rule of having same functions and variables as in the interface. Extends will create a child copy of parents which is inheritance

80)Object destructuring -

this.state.count === 0? 'Zero' : this.state.count

can be written as

//pick the count property and store it in variable count
{ count } = this.state
count === 0? 'Zero' : count

81)The jsx html code gets compiled to React.createElement Object. Hence we cannot use reserved words like class etc inside JSX

82)true && false > false
true && 'Hi' > Hi
true && 'Hi' && 1 > 1

The result will be final truthy operand

83)this object with below scenarios
Scenario 1 - Function inside Object Scenario

var some1 = { 
	name : 'manj',
	ageFun : function(){ 
    console.log('func called', this) 
    }
}

some1.ageFun();
//func called {name: "manj", ageFun: ƒ}

Scenario 2 - Stand Alone Function Scenario

function som() { console.log(this) }
//Window {postMessage: ƒ, blur: ƒ, focus: ƒ, close: ƒ, parent: Window, …}

If strict mode is enabled then the standalone function then this returns undefined

84)In some cases you might have a scenario where the this object wont be available to use in the standalone function. In such cases we will use .bind(this) whereever the this object is available. Generally the constructor will have acess to the this keyword

constructor() {
        super()
        console.log('From constructor', this)
        this.handleIncrement = this.handleIncrement.bind(this)
}

handleIncrement() {
    console.log('Stand alone', this)
}

OR

handleIncrement = () => {
    console.log('Stand alone', this)
}

Here the below approach is simpler and the arrow approach is best used because the this object is inherited by arrow function syntax.

Arrow functions don't have their own this or arguments binding. Instead, those identifiers are resolved in the lexical scope like any other variable. That means that inside an arrow function, this and arguments refer to the values of this and arguments in the environment the arrow function is defined in (i.e. "outside" the arrow function):

85)setState comes from Component class.

86)The events like onClick or onKey should be pased with a function reference.

onClick={this.handleIncrement}

If i have to pas args then I CANT DO THIS as reference should be passed

onClick={this.handleIncrement()}

To overcome the scenario

onClick={() => { this.handleIncrement(param) }

87)props are readonly where as state can be changed

88)Awesome Approach for deleting

delete the record with counterId = 2

const counters = this.state.counters.filter(c => c.id !== counterId)

89)whenever we are NOT dealing with state in a component then make such components as stateless ie function type

90)import Button from 'react-bootstrap/Button';

// or less ideally
import { Button } from 'react-bootstrap';

91)For setting up Redux, check changes in index.js of train project and 2 steps to follow are
- We need to map the redux state to our local props so mapSTateToProps()
- We need to set up a mini class kind which holds the necessary actions we dispatch in the component mapDispatchToProps()

92)If the component is loaded via Route tag then the props will have access to the location,match etc. If the same component is loaded without Route as a part of some other return() of some other component then NO access to location and match. If we still want to have those for non routed component then use withRouter

93)React, unlike Angular, has one-way data-binding. One-way data binding means that React is more performant than Angular and also makes debugging a React app easier than debugging an Angular app, in my opinion. A unidirectional data flow means that when designing a React app you often nest child components within higher-order parent components.

The parent component(s) will have a container for the state of your app (typically an immutable variable called state, unless you are using Redux or Flux, in which case you would encapsulate your app’s state in a store). The parent component typically passes down a snapshot of its state to its child components via read-only props and then the child components can communicate with the parent to update the state via callbacks which are bound to a button or form in the child component.

94)Redux comes to rescue of the above situtation

95)Reducer is synchronous always and inorder to run async code inside the reducer, we need to make use of action creators

96)Redux Thunk is a Middleware used for async in redux react.

97)Since reducer is a synchronous func, we cannot write any async code there. Hence we need to write it in the action as action creator which will call the api and after the result of the API is returned then we are going to reducers. So it is like a Middleware which makes the API after action and before the reducer

98)We can however use componentDidMount for API call and once result is recieved then dispatch the action. Sometimes you might need to use action creators inorder to execute the API and thunk Middleware. Either approach can be done. 

99)I want the initialState of the store to have the response of API.The index.js where the store is initialized createStore accepts reducer and initialState as second param. Here we make use of middleware

100)To modify the local state we use setState and to modify the store we use redux action

101)reactjs follows some guidelines like WCAG - web content accessibility guidelines which means it is set of rules to be followed for any website for anyone.Web accessibility (also referred to as a11y) is the design and creation of websites that can be used by everyone. Accessibility support is necessary to allow assistive technology to interpret web pages. WCAG includes some of the rules like alternative text for images, subtitles for video.

Accessible Rich Internet Applications (ARIA) is a set of attributes that define ways to make web content and web applications (especially those developed with JavaScript) more accessible to people with disabilities. 

WAI-ARIA is a spec defining support for accessible web apps. It defines bunch of markup extensions (mostly as attributes on HTML5 elements), which can be used by the web app developer to provide additional information about the semantics of the various elements to assistive technologies like screen readers. Of course, for ARIA to work, the HTTP user agent that interprets the markup needs to support ARIA, but the spec is created in such a way, as to allow down-level user agents to ignore the ARIA-specific markup safely without affecting the web app's functionality.
WAI-ARIA is an incredibly powerful technology that allows developers to easily describe the purpose, state and other functionality of visually rich user interfaces - in a way that can be understood by Assistive Technology. WAI-ARIA has finally been integrated into the current working draft of the HTML 5 specification.

102)A semantic element clearly describes its meaning to both the browser and the developer.
Examples of non-semantic elements: <div> and <span> - Tells nothing about its content.
Examples of semantic elements: <form>, <table>, and <article> - Clearly defines its content.
https://reactjs.org/docs/accessibility.html

103)When you don’t need any props on the Fragment tag you can use the short syntax, if your tooling supports it:

return(
  <>
    <dt>Hi </dt>
  <>
)

instead of 

return(
  <Fragment>
    <dt>Hi </dt>
  <Fragment>
)

104)Refs provide a way to access DOM nodes or React elements created in the render method.In the typical React dataflow, props are the only way that parent components interact with their children. To modify a child, you re-render it with new props. However, there are a few cases where you need to imperatively modify a child outside of the typical dataflow. The child to be modified could be an instance of a React component, or it could be a DOM element. For both of these cases, React provides an escape hatch

return (
    <input
      type="text"
      ref={this.textInput}
    />
  );

focus() {
  // Explicitly focus the text input using the raw DOM API
  // Note: we're accessing "current" to get the DOM node
  this.textInput.current.focus();
}

105)The short story: access of this in a subclass before super() call is not allowed, because in ES6 this is being born in the base class, therefore super() is needed to initialize it.
super() will calls the constructor of its parent class. This is required when you need to access some variables from the parent class.

106)Webpack is a bundler which minimizes the code size and not just it but also it optimises the images if any used in application.

107)While deploying the application in the internet, we build it using npm build and then make the server serve the index.html from the build/ folder. 

108)The Webpack bundles the files in such way that they are bundled  in orderly manner. However we should mention entryPoint from where it should start bundling. We usually give single entry point like app.js

109)Webpack Steps

npm install --save-dev webpack webpack-dev-server

These are dev dependencies hence --save-dev

We need to make the webpack understand the jsx and convert it to javascript and other css minifying

110)A script has to  be executed to initiate webpack. In package.json there is script where the command should be present corresponding to the webpack-dev-server which then tries to find webpack.config.ts file for commands on seeing the script command webpack-dev-server

All the imports of css related links will be replaced with styles directly in index file and 
All the images would be converted to base64 format by keeping inline store of images and links to these images would be provided by the file-loader

111)
render() {
      return <WrappedComponent {...this.props} />;
    }

112)JSX Prevents Injection Attacks
It is safe to embed user input in JSX:

const title = response.potentiallyMaliciousInput;
// This is safe:
const element = <h1>{title}</h1>;

By default, React DOM escapes any values embedded in JSX before rendering them. Thus it ensures that you can never inject anything that’s not explicitly written in your application. Everything is converted to a string before being rendered. This helps prevent XSS (cross-site-scripting) attacks.

113)Steps of JSX conversionn

const element = (
  <h1 className="greeting">
    Hello, world!
  </h1>
);

const element = React.createElement(
  'h1',
  {className: 'greeting'},
  'Hello, world!'
);

/ Note: this structure is simplified
const element = {
  type: 'h1',
  props: {
    className: 'greeting',
    children: 'Hello, world!'
  }
};

114)<div id="root"></div>
We call this a “root” DOM node because everything inside it will be managed by React DOM.

115)To render a React element into a root DOM node, pass both to ReactDOM.render():

const element = <h1>Hello, world</h1>;
ReactDOM.render(element, document.getElementById('root'));

ReactDOM(What?,Where?)

116)When React sees an element representing a user-defined component, it passes JSX attributes to this component as a single object. We call this object “props”.

const element = <Welcome name="Sara" />;

117)React treats components starting with lowercase letters as DOM tags. For example, <div /> represents an HTML div tag, but <Welcome /> represents a component and requires Welcome to be in scope.

118)Whether you declare a component as a function or a class, it must never modify its own props. Consider this sum function:

function sum(a, b) {
  return a + b;
}
Such functions are called “pure” because they do not attempt to change their inputs, and always return the same result for the same inputs.
In contrast, this function is impure because it changes its own input:

function withdraw(account, amount) {
  account.total -= amount;
}

119)This is commonly called a “top-down” or “unidirectional” data flow. Any state is always owned by some specific component, and any data or UI derived from that state can only affect components “below” them in the tree.

120)Data flow is unidrectional in Reactjs.
  - The data or state from the parents will come down to children as PROPS and PROPS cannot be modified by children
  - The PROPS passed to the children are having LOCAL STATES and won't interfere with the actual state or PROPS
  - The modification in the STATE should be done in the component which is maintaining the state and no where else. 
  - The data flows in top to bottom approach

121)JSX -
  const element = <div className="greeting">hi there</div>

The above is neither string nor javascript but it is JSX
Babel internally converts the JSX expression to -

const element = React.createElement(
  'div',
  {className: 'greeting'},
  'hi there'
);

Essentially it creates an object like this

const element = {
  type: 'h1',
  props: {
    className: 'greeting',
    children: 'Hello, world!'
  }
};

122)
<button onClick={(e) => this.deleteRow(id, e)}>Delete Row</button>
<button onClick={this.deleteRow.bind(this, id)}>Delete Row</button>

The above two lines are equivalent, and use arrow functions and Function.prototype.bind respectively.

In both cases, the e argument representing the React event will be passed as a second argument after the ID. With an arrow function, we have to pass it explicitly, but with bind any further arguments are automatically forwarded.

123)Lazy loading/Code splitting is one of the most compelling features of webpack. This feature allows you to split your code into various bundles which can then be loaded on demand or in parallel. It can be used to achieve smaller bundles and control resource load prioritization which, if used correctly, can have a major impact on load time.
Code-splitting your app can help you “lazy-load” just the things that are currently needed by the user, which can dramatically improve the performance of your app. While you haven’t reduced the overall amount of code in your app, you’ve avoided loading code that the user may never need, and reduced the amount of code needed during the initial load.
The best way to introduce code-splitting into your app is through the dynamic import() syntax.

BEFORE
import { add } from './math';

console.log(add(16, 26));

AFTER
import("./math").then(math => {
  console.log(math.add(16, 26));
});

124)React.lazy - The React.lazy function lets you render a dynamic import as a regular component.

Before:
import OtherComponent from './OtherComponent';

After:
const OtherComponent = React.lazy(() => import('./OtherComponent'));

Suspense is a component required by the lazy function basically used to wrap lazy components. Multiple lazy components can be wrapped with the suspense component. It takes a fallback property that accepts the react elements you want to render as the lazy component is being loaded.

125)Code splitting works only for webpack available applications

126)In a typical React application, data is passed top-down (parent to child) via props, but this can be cumbersome for certain types of props (e.g. locale preference, UI theme) that are required by many components within an application. Context provides a way to share values like these between components without having to explicitly pass a prop through every level of the tree.

127)In a typical React application, data is passed top-down (parent to child) via props, but this can be cumbersome for certain types of props (e.g. locale preference, UI theme) that are required by many components within an application. Context provides a way to share values like these between components without having to explicitly pass a prop through every level of the tree.

128)A simple flaw or error in the application can break the entire application. Inorder to save that, we
need to catch the errors separately without interrupting the regular flow

Error boundaries do not catch errors for:

Event handlers (learn more)
Asynchronous code (e.g. setTimeout or requestAnimationFrame callbacks)
Server side rendering
Errors thrown in the error boundary itself (rather than its children)

A class component becomes an error boundary if it defines either (or both) of the lifecycle methods static getDerivedStateFromError() or componentDidCatch(). Use static getDerivedStateFromError() to render a fallback UI after an error has been thrown. Use componentDidCatch() to log error information.

129)Static method calls are made directly on the class and are not callable on instances of the class. Static methods are often used to create utility functions.

130)The concept of the react profiler is to collect timing information about components, the time rendered and committed in order to identify when each component actually rendered and at what speed. Basically to explain to you how fast or how slow your application is.

131)Web Components is a suite of different technologies allowing you to create reusable custom elements — with their functionality encapsulated away from the rest of your code — and utilize them in your web apps.

React and Web Components are built to solve different problems. Web Components provide strong encapsulation for reusable components, while React provides a declarative library that keeps the DOM in sync with your data. The two goals are complementary. As a developer, you are free to use React in your Web Components, or to use Web Components in React, or both.Most people who use React don’t use Web Components, but you may want to, especially if you are using third-party UI components that are written using Web Components.

Using Web Components in React

class HelloMessage extends React.Component {
  render() {
    return <div>Hello <x-search>{this.props.name}</x-search>!</div>;
  }
}

One common confusion is that Web Components use “class” instead of “className”.

Using React in your Web Components

class XSearch extends HTMLElement {
  connectedCallback() {
    const mountPoint = document.createElement('span');
    this.attachShadow({ mode: 'open' }).appendChild(mountPoint);

    const name = this.getAttribute('name');
    const url = 'https://www.google.com/search?q=' + encodeURIComponent(name);
    ReactDOM.render(<a href={url}>{name}</a>, mountPoint);
  }
}
customElements.define('x-search', XSearch);

132)Uncontrolled Components - In React, it is called an uncontrolled component because its value can only be set by a user, and not programmatically.

 In most cases, we recommend using controlled components to implement forms. In a controlled component, form data is handled by a React component. The alternative is uncontrolled components, where form data is handled by the DOM itself.

To write an uncontrolled component, instead of writing an event handler for every state update, you can use a ref to get form values from the DOM.In the React rendering lifecycle, the value attribute on form elements will override the value in the DOM. With an uncontrolled component, you often want React to specify the initial value, but leave subsequent updates uncontrolled. To handle this case, you can specify a defaultValue attribute instead of value.

In React, an <input type="file" /> is always an uncontrolled component because its value can only be set by a user, and not programmatically.

this.fileInput = React.createRef();
<input type="file" ref={this.fileInput} />
this.fileInput.current.files[0].name

the above 3 lines for file in 3 different places. More info check Form_ref

133)Type Checking In JavaScript: Flow is a static type checker that catches common errors in your application before they run.

As your app grows, you can catch a lot of bugs with typechecking. For some applications, you can use JavaScript extensions like Flow or TypeScript to typecheck your whole application. But even if you don’t use those, React has some built-in typechecking abilities. To run typechecking on the props for a component, you can assign the special propTypes property:

134)Strict mode checks are run in development mode only; they do not impact the production build.
StrictMode currently helps with:

Identifying components with unsafe lifecycles
Warning about legacy string ref API usage
Warning about deprecated findDOMNode usage
Detecting unexpected side effects
Detecting legacy context API
Additional functionality will be added with future releases of React.

135)Sharing of values between the components is known and here you share the function between the components.

<DataProvider render={data => (
  <h1>Hello {data.target}</h1>
)}/>

136)The Diffing Algorithm

When diffing two trees, React first compares the two root elements. The behavior is different depending on the types of the root elements.

- Elements Of Different Types

    Whenever the root elements have different types, React will tear down the old tree and build the new tree from scratch. Going from <a> to <img>, or from <Article> to <Comment>, or from <Button> to <div> - any of those will lead to a full rebuild.

    When tearing down a tree, old DOM nodes are destroyed. Component instances receive componentWillUnmount(). When building up a new tree, new DOM nodes are inserted into the DOM. Component instances receive componentWillMount() and then componentDidMount(). Any state associated with the old tree is lost.
    Any components below the root will also get unmounted and have their state destroyed. For example, when diffing:

    <div>
      <Counter />
    </div>

    <span>
      <Counter />
    </span>
    This will destroy the old Counter and remount a new one.

- DOM Elements Of The Same Type

    When comparing two React DOM elements of the same type, React looks at the attributes of both, keeps the same underlying DOM node, and only updates the changed attributes. For example:

    <div className="before" title="stuff" />

    <div className="after" title="stuff" />
    By comparing these two elements, React knows to only modify the className on the underlying DOM node.

- Recursing On Children

    By default, when recursing on the children of a DOM node, React just iterates over both lists of children at the same time and generates a mutation whenever there’s a difference.

    For example, when adding an element at the end of the children, converting between these two trees works well:

    <ul>
      <li>first</li>
      <li>second</li>
    </ul>

    <ul>
      <li>first</li>
      <li>second</li>
      <li>third</li>
    </ul>
    React will match the two <li>first</li> trees, match the two <li>second</li> trees, and then insert the <li>third</li> tree.

    If you implement it naively, inserting an element at the beginning has worse performance. For example, converting between these two trees works poorly:

    <ul>
      <li>Duke</li>
      <li>Villanova</li>
    </ul>

    <ul>
      <li>Connecticut</li>
      <li>Duke</li>
      <li>Villanova</li>
    </ul>

    React will mutate every child instead of realizing it can keep the <li>Duke</li> and <li>Villanova</li> subtrees intact. This inefficiency can be a problem.

- Keys
    In order to solve this issue, React supports a key attribute. When children have keys, React uses the key to match children in the original tree with children in the subsequent tree. For example, adding a key to our inefficient example above can make the tree conversion efficient:

    <ul>
      <li key="2015">Duke</li>
      <li key="2016">Villanova</li>
    </ul>

    <ul>
      <li key="2014">Connecticut</li>
      <li key="2015">Duke</li>
      <li key="2016">Villanova</li>
    </ul>
    Now React knows that the element with key '2014' is the new one, and the elements with the keys '2015' and '2016' have just moved.

It is important to remember that the reconciliation algorithm is an implementation detail. React could rerender the whole app on every action; the end result would be the same. 
Just to be clear, rerender in this context means calling render for all components, it doesn’t mean React will unmount and remount them. It will only apply the differences following the rules stated in the previous sections.

137)React Without ES6

class Greeting extends React.Component {
  render() {
    return <h1>Hello, {this.props.name}</h1>;
  }
}
If you don’t use ES6 yet, you may use the create-react-class module instead:

var createReactClass = require('create-react-class');
var Greeting = createReactClass({
  render: function() {
    return <h1>Hello, {this.props.name}</h1>;
  }
});

138)Portals - An API for rendering components outside of your app’s DOM hierarchy.
Perfect for scenarios where CSS styles are restraining your elements. For example, stacking(z-index) and overflow issues. You could even render things in a new window.
A brilliant thing about portals is that a component rendered in a portal acts as if it is still in the React tree. It behaves like a normal React child. You can pass it props, it will react to updates etc.

139)When an element type starts with a lowercase letter, it refers to a built-in component like <div> or <span> and results in a string 'div' or 'span' passed to React.createElement. Types that start with a capital letter like <Foo /> compile to React.createElement(Foo) and correspond to a component defined or imported in your JavaScript file.

<MyComponent foo={1 + 2 + 3 + 4} />
<MyComponent foo={1} />

You can pass a string literal as a prop. These two JSX expressions are equivalent:
<MyComponent message="hello world" />
<MyComponent message={'hello world'} />

When you pass a string literal, its value is HTML-unescaped. So these two JSX expressions are equivalent:
<MyComponent message="&lt;3" />
<MyComponent message={'<3'} />

Props Default to “True”
If you pass no value for a prop, it defaults to true. These two JSX expressions are equivalent:
<MyTextBox autocomplete />
<MyTextBox autocomplete={true} />

function App2() {
  const props = {firstName: 'Ben', lastName: 'Hector'};
  return <Greeting {...props} />;
}
return <button className={className} {...other} />;

140)these all render to the same thing:

<div>Hello World</div>

<div>
  Hello World
</div>

<div>
  Hello
  World
</div>

<div>

  Hello World
</div>

141)Booleans, Null, and Undefined Are Ignored
false, null, undefined, and true are valid children. They simply don’t render. These JSX expressions will all render to the same thing:

<div />
<div></div>
<div>{false}</div>
<div>{null}</div>
<div>{undefined}</div>
<div>{true}</div>

This can be useful to conditionally render React elements. This JSX renders the <Header /> component only if showHeader is true:
<div>
  {showHeader && <Header />}
  <Content />
</div>

142)React is the entry point to the React library. If you load React from a <script> tag, these top-level APIs are available on the React global. If you use ES6 with npm, you can write import React from 'react'. If you use ES5 with npm, you can write var React = require('react').

143)CloneElement()
React.cloneElement(
  element,
  [props],
  [...children]
)
Clone and return a new React element using element as the starting point. The resulting element will have the original element’s props with the new props merged in shallowly. New children will replace existing children. key and ref from the original element will be preserved.

React.cloneElement() is almost equivalent to:

<element.type {...element.props} {...props}>{children}</element.type>
However, it also preserves refs. This means that if you get a child with a ref on it, you won’t accidentally steal it from your ancestor. You will get the same ref attached to your new element.

144)Constructor is the only place where you should assign this.state directly. In all other methods, you need to use this.setState() instead.

145)getSnapshotBeforeUpdate()
getSnapshotBeforeUpdate(prevProps, prevState)
getSnapshotBeforeUpdate() is invoked right before the most recently rendered output is committed to e.g. the DOM. It enables your component to capture some information from the DOM (e.g. scroll position) before it is potentially changed. Any value returned by this lifecycle will be passed as a parameter to componentDidUpdate().

146)In React, all DOM properties and attributes (including event handlers) should be camelCased. For example, the HTML attribute tabindex corresponds to the attribute tabIndex in React. The exception is aria-* and data-* attributes, which should be lowercased. For example, you can keep aria-label as aria-label.

147)checked
The checked attribute is supported by <input> components of type checkbox or radio. You can use it to set whether the component is checked. This is useful for building controlled components. defaultChecked is the uncontrolled equivalent, which sets whether the component is checked when it is first mounted.

148)dangerouslySetInnerHTML
dangerouslySetInnerHTML is React’s replacement for using innerHTML in the browser DOM. In general, setting HTML from code is risky because it’s easy to inadvertently expose your users to a cross-site scripting (XSS) attack. So, you can set HTML directly from React, but you have to type out dangerouslySetInnerHTML and pass an object with a __html key, to remind yourself that it’s dangerous. For example:

function createMarkup() {
  return {__html: 'First &middot; Second'};
}

function MyComponent() {
  return <div dangerouslySetInnerHTML={createMarkup()} />;
}

149)Cross-site scripting (XSS) is a type of computer security vulnerability typically found in web applications. XSS enables attackers to inject client-side scripts into web pages viewed by other users. A cross-site scripting vulnerability may be used by attackers to bypass access controls such as the same-origin policy. 

15)style in two ways
// Result style: '10px'
<div style={{ height: 10 }}>
  Hello World!
</div>

or

const divStyle = {
  color: 'blue',
  backgroundImage: 'url(' + imgUrl + ')',
};
function HelloWorldComponent() {
  return <div style={divStyle}>Hello World!</div>;
}

16)A polyfill is a piece of code (usually JavaScript on the Web) used to provide modern functionality on older browsers that do not natively support it

17)React 16 depends on the collection types Map and Set. If you support older browsers and devices which may not yet provide these natively (e.g. IE < 11) or which have non-compliant implementations (e.g. IE 11), consider including a global polyfill in your bundled application, such as core-js or babel-polyfill.

18)The event handlers will be passed as instances of SyntheticEvent, a cross-browser wrapper around the browser’s native event. It has the same interface as the browser’s native event, including stopPropagation() and preventDefault(), except the events work identically across all browsers.

If you find that you need the underlying browser event for some reason, simply use the nativeEvent attribute to get it.
onChange onInput onInvalid onSubmit
DOMEventTarget relatedTarget
onFocus onBlur
onClick onContextMenu onDoubleClick onDrag onDragEnd onDragEnter onDragExit

suppressHydrationWarning - If you use server-side React rendering, normally there is a warning when the server and the client render different content. However, in some rare cases, it is very hard or impossible to guarantee an exact match. For example, timestamps are expected to differ on the server and on the client.

19)React.memo is used to wrap the component and doesnot cause render unless the props are changed.Mostly when we are just rendering the html code

20)There are functional and class based components. Inorder to change state, we use class based as u can use redux methods inside class based components. In functional components we would max display or pass events or the data across but not manipulate the state. Now there is something called as React Hooks which would make a function capable to change the state and using react hooks, we can avoid class based completely. React hooks let you create lifecycles and also state manipulation

Hooks are functions that let you “hook into” React state and lifecycle features from function components. Hooks don’t work inside classes — they let you use React without classes

21)React hooks can manage state where state need not be an object but can be anything like boolean or string anything

22)useState returns initial state with the callback to modify the state.